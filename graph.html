<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Collaboration Graph — DBLP</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --bg:#0f172a; --card:#111827; --text:#e5e7eb; --muted:#9ca3af; --accent:#60a5fa; --accent2:#34d399; }
    * { box-sizing: border-box; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji"; background:var(--bg); color:var(--text); }
    header { padding:18px 20px; border-bottom:1px solid #1f2937; display:flex; gap:16px; align-items:center; flex-wrap:wrap; background:#0b1220; position:sticky; top:0; z-index:10;}
    header h1 { margin:0; font-size:18px; font-weight:700; letter-spacing:.2px; }
    .controls { display:flex; gap:10px; align-items:end; flex-wrap:wrap; width:100%; }
    label { font-size:12px; color:var(--muted); display:block; margin-bottom:6px; }
    input[type="text"] { background:#0b1220; border:1px solid #1f2937; color:var(--text); padding:10px 12px; border-radius:10px; width:260px; }
    .btn { background:linear-gradient(135deg, var(--accent), #8b5cf6); color:white; border:none; padding:10px 14px; border-radius:10px; cursor:pointer; font-weight:700; }
    .btn.secondary { background:#1f2937; }
    .hint { font-size:12px; color:var(--muted); }
    .wrap { display:flex; height: calc(100vh - 82px); }
    #graph { flex:1; }
    .side { width:320px; border-left:1px solid #1f2937; padding:16px; overflow:auto; background:#0b1220; }
    .stat { margin-bottom:10px; font-size:14px; }
    .pill { display:inline-block; padding:4px 8px; border:1px solid #1f2937; border-radius:999px; margin:2px; font-size:12px; color:#cbd5e1; background:#0f172a; }
    .legend { display:flex; gap:10px; margin:8px 0 16px; flex-wrap:wrap; }
    .legend span { display:inline-flex; align-items:center; gap:6px; font-size:12px; color:#cbd5e1; }
    .legend i { width:12px; height:12px; display:inline-block; border-radius:50%; background:#64748b; }
    .legend i.me { background:var(--accent2); }
    .legend i.co { background:#94a3b8; }
    .legend i.peer { background:#475569; }
    .error { color:#fca5a5; font-size:13px; margin-top:8px; }
    a { color:#93c5fd; text-decoration:none; }
    a:hover { text-decoration:underline; }
    svg text { fill:#d1d5db; pointer-events:none; font-size:11px; paint-order: stroke; stroke: #0b1220; stroke-width: 3px; }
    .node circle { stroke:#0b1220; stroke-width:1px; }
    .node.me circle { stroke:var(--accent2); stroke-width:2px; }
    .link { stroke:#3b82f6; stroke-opacity:.25; }
    .link.peer { stroke:#64748b; stroke-opacity:.25; }
    .badge { background:#111827; border:1px solid #1f2937; padding:6px 10px; border-radius:10px; display:inline-flex; gap:8px; align-items:center; }
  </style>
</head>
<body>
  <header>
    <h1>DBLP Collaboration Graph</h1>
    <div class="controls">
      <div>
        <label for="pid">DBLP PID (person)</label>
        <input id="pid" type="text" value="68/7553-1" placeholder="e.g., 68/7553-1" />
      </div>
      <div>
        <label for="authorName">JSONP Fallback (exact author name)</label>
        <input id="authorName" type="text" value="Daniel de Oliveira" placeholder="Only used if XML fetch fails" />
        <div class="hint">If needed, used with DBLP search API (format=jsonp) as a fallback.</div>
      </div>
      <button id="build" class="btn">Build Graph</button>
      <button id="togglePeers" class="btn secondary">Toggle Coauthor↔Coauthor</button>
      <button id="exportPNG" class="btn secondary">Export PNG</button>
      <span id="status" class="hint"></span>
    </div>
  </header>

  <div class="wrap">
    <div id="graph"></div>
    <aside class="side">
      <div class="legend">
        <span><i class="me"></i> Focal author</span>
        <span><i class="co"></i> Coauthor</span>
        <span><i class="peer"></i> Coauthor↔Coauthor link</span>
      </div>
      <div class="stat" id="who"></div>
      <div class="stat"><span class="badge">Nodes: <b id="nodesCount">–</b></span></div>
      <div class="stat"><span class="badge">Edges: <b id="edgesCount">–</b></span></div>
      <div class="stat"><span class="badge">Papers parsed: <b id="papersCount">–</b></span></div>
      <h3 style="margin:16px 0 8px;">Top Coauthors</h3>
      <div id="topCoauthors"></div>
      <h3 style="margin:16px 0 8px;">Tips</h3>
      <ul class="hint" style="margin-top:8px; padding-left:18px; line-height:1.5">
        <li>Use the PID from your DBLP person page URL (e.g., <code>68/7553-1</code>).</li>
        <li>If your host blocks cross-origin XML, fill the fallback author name (exact) and we’ll use the DBLP JSONP search API.</li>
        <li>Drag nodes; scroll/trackpad to zoom; click & drag background to pan.</li>
      </ul>
      <div id="err" class="error"></div>
    </aside>
  </div>

  <!-- D3.js -->
  <script src="https://unpkg.com/d3@7"></script>

  <script>
    const els = {
      pid: document.getElementById('pid'),
      authorName: document.getElementById('authorName'),
      build: document.getElementById('build'),
      togglePeers: document.getElementById('togglePeers'),
      exportPNG: document.getElementById('exportPNG'),
      status: document.getElementById('status'),
      who: document.getElementById('who'),
      nodesCount: document.getElementById('nodesCount'),
      edgesCount: document.getElementById('edgesCount'),
      papersCount: document.getElementById('papersCount'),
      topCoauthors: document.getElementById('topCoauthors'),
      err: document.getElementById('err'),
      graph: document.getElementById('graph'),
    };

    let includePeerEdges = false;
    let simulation, svg, gLinks, gNodes, gLabels, zoom;
    let currentData = null;

    els.togglePeers.onclick = () => {
      includePeerEdges = !includePeerEdges;
      if (currentData) render(currentData.nodes, currentData.links, currentData.meKey);
    };

    els.exportPNG.onclick = () => exportSvgAsPng();

    els.build.onclick = () => build();

    async function build() {
      resetUI();
      const pid = els.pid.value.trim();
      if (!pid) return setError('Please enter a DBLP PID.');
      setStatus('Fetching DBLP XML…');
      try {
        const xmlUrl = `https://dblp.org/pid/${pid}.xml`;
        const res = await fetch(xmlUrl, { mode: 'cors' });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const xmlText = await res.text();
        const dom = new DOMParser().parseFromString(xmlText, 'application/xml');
        if (dom.querySelector('parsererror')) throw new Error('Invalid XML from DBLP.');
        const { nodes, links, meKey, papers, top } = buildFromXML(dom, pid);
        currentData = { nodes, links, meKey };
        setStatus('OK');
        updateStats(papers, nodes, links, meKey, top);
        render(nodes, links, meKey);
      } catch (e) {
        console.warn('XML fetch failed, trying JSONP fallback…', e);
        const name = els.authorName.value.trim();
        if (!name) return setError('XML fetch failed. Enter an exact author name for JSONP fallback, then click “Build Graph”.');
        try {
          setStatus('Using DBLP search API (JSONP)…');
          const records = await fetchJSONPForAuthor(name);
          const { nodes, links, meKey, papers, top } = buildFromJSONP(records, name);
          currentData = { nodes, links, meKey };
          setStatus('OK (fallback)');
          updateStats(papers, nodes, links, meKey, top);
          render(nodes, links, meKey);
        } catch (e2) {
          setError('Both XML and JSONP fallback failed. Check PID/name or try from a different host.');
          console.error(e2);
        }
      }
    }

    function resetUI() {
      els.err.textContent = '';
      els.status.textContent = '';
      els.nodesCount.textContent = '–';
      els.edgesCount.textContent = '–';
      els.papersCount.textContent = '–';
      els.topCoauthors.innerHTML = '';
      els.who.innerHTML = '';
      d3.select(els.graph).selectAll('*').remove();
    }

    function setStatus(msg) { els.status.textContent = msg; }
    function setError(msg) { els.err.textContent = msg; els.status.textContent = ''; }

    // --- Parse DBLP person XML ---
    function buildFromXML(dom, targetPid) {
      const records = [];
      // DBLP person XML root: <dblpperson> with many <r> wrappers
      dom.querySelectorAll('dblpperson > r').forEach(r => {
        const pub = r.querySelector(':scope > *:not(info)');
        if (!pub) return;
        const title = (pub.querySelector('title')?.textContent || '').trim();
        const year = (pub.querySelector('year')?.textContent || '').trim();
        const authEls = pub.querySelectorAll('author, editor');
        if (!authEls.length) return;
        const authors = Array.from(authEls).map(a => ({
          name: (a.textContent || '').trim(),
          pid: (a.getAttribute('pid') || '').trim()
        }));
        records.push({ title, year, authors });
      });

      // Build nodes/edges
      const meKey = targetPid; // key authors by pid when available; fallback to name
      const nodeMap = new Map(); // key -> {id,label,isMe,count}
      const edgeMap = new Map(); // "a||b" sorted -> weight
      const paperCountByCo = new Map();
      let papersWithMe = 0;

      for (const rec of records) {
        const hasMe = rec.authors.some(a => a.pid.includes(meKey));
        if (!hasMe) continue;
        papersWithMe++;
        // ensure me node label (prefer the exact signature label if present)
        const meLabel = rec.authors.find(a => a.pid.includes(meKey))?.name || 'Me';
        touchNode(meKey, meLabel, true);
        const others = rec.authors.filter(a => !a.pid.includes(meKey));
        for (const co of others) {
          const key = co.pid || co.name;
          const label = co.name || key;
          touchNode(key, label, false);
          addEdge(meKey, key, 1);
          paperCountByCo.set(key, (paperCountByCo.get(key) || 0) + 1);
        }
        if (includePeerEdges) {
          // connect coauthors among themselves for this paper
          for (let i = 0; i < others.length; i++) {
            for (let j = i + 1; j < others.length; j++) {
              const a = others[i].pid || others[i].name;
              const b = others[j].pid || others[j].name;
              addEdge(a, b, 1, true);
            }
          }
        }
      }

      const nodes = Array.from(nodeMap.values());
      const links = Array.from(edgeMap.entries()).map(([k, v]) => {
        const [a, b, peer] = k.split('||');
        return { source: a, target: b, weight: v, peer: peer === 'peer' };
      });

      // Top coauthors
      const top = Array.from(paperCountByCo.entries())
        .sort((a,b) => b[1]-a[1])
        .slice(0, 15)
        .map(([key, n]) => ({ key, n, name: nodeMap.get(key)?.label || key }));

      return { nodes, links, meKey, papers: papersWithMe, top };

      function touchNode(key, label, isMe) {
        if (!nodeMap.has(key)) nodeMap.set(key, { id: key, label, isMe, degree:0 });
        if (isMe) nodeMap.get(key).isMe = true;
      }
      function addEdge(a, b, w = 1, peer=false) {
        const aa = String(a), bb = String(b);
        if (aa === bb) return;
        const [s, t] = aa < bb ? [aa, bb] : [bb, aa];
        const k = peer ? `${s}||${t}||peer` : `${s}||${t}||me`;
        edgeMap.set(k, (edgeMap.get(k) || 0) + w);
      }
    }

    // --- JSONP fallback using DBLP search API (exact author name) ---
    // Docs: https://dblp.org/faq/How+to+use+the+dblp+search+API.html (format=jsonp, &callback=...)
    function fetchJSONPForAuthor(name) {
      const cb = `dblp_cb_${Date.now()}_${Math.random().toString(36).slice(2)}`;
      const q = encodeURIComponent(`author:${name.replace(/\s+/g, '_')}:`);
      const url = `https://dblp.org/search/publ/api?q=${q}&h=1000&format=jsonp&callback=${cb}`;
      return new Promise((resolve, reject) => {
        const s = document.createElement('script');
        const timeout = setTimeout(() => {
          cleanup(); reject(new Error('JSONP timeout'));
        }, 15000);
        window[cb] = (data) => {
          cleanup();
          try {
            const hits = data?.result?.hits?.hit || [];
            const recs = hits.map(h => {
              const info = h.info || {};
              const authors = normalizeAuthors(info.authors?.author);
              return { title: info.title || '', year: info.year || '', authors };
            });
            resolve(recs);
          } catch (e) { reject(e); }
        };
        s.src = url;
        s.onerror = () => { cleanup(); reject(new Error('JSONP script error')); };
        document.head.appendChild(s);
        function cleanup(){ clearTimeout(timeout); delete window[cb]; s.remove(); }
      });

      function normalizeAuthors(a) {
        if (!a) return [];
        const arr = Array.isArray(a) ? a : [a];
        return arr.map(x => ({ name: (typeof x === 'string' ? x : x?.text || x).trim(), pid: '' }));
      }
    }

    function buildFromJSONP(records, authorNameExact) {
      const nodeMap = new Map();
      const edgeMap = new Map();
      const meKey = `me::${authorNameExact}`;
      let papers = 0;
      const paperCountByCo = new Map();

      for (const rec of records) {
        const authors = rec.authors;
        if (!authors.length) continue;
        const hasMe = authors.some(a => a.name === authorNameExact);
        if (!hasMe) continue; // JSONP query uses exact author:NAME:
        papers++;
        touchNode(meKey, authorNameExact, true);
        const others = authors.filter(a => a.name !== authorNameExact);
        for (const co of others) {
          const key = co.name;
          touchNode(key, key, false);
          addEdge(meKey, key, 1);
          paperCountByCo.set(key, (paperCountByCo.get(key) || 0) + 1);
        }
        if (includePeerEdges) {
          for (let i = 0; i < others.length; i++) {
            for (let j = i + 1; j < others.length; j++) {
              addEdge(others[i].name, others[j].name, 1, true);
            }
          }
        }
      }

      const nodes = Array.from(nodeMap.values());
      const links = Array.from(edgeMap.entries()).map(([k, v]) => {
        const [a, b, peer] = k.split('||');
        return { source: a, target: b, weight: v, peer: peer === 'peer' };
      });
      const top = Array.from(paperCountByCo.entries())
        .sort((a,b)=>b[1]-a[1]).slice(0,15)
        .map(([key, n]) => ({ key, n, name: key }));
      return { nodes, links, meKey, papers, top };

      function touchNode(key, label, isMe) {
        if (!nodeMap.has(key)) nodeMap.set(key, { id:key, label, isMe, degree:0 });
        if (isMe) nodeMap.get(key).isMe = true;
      }
      function addEdge(a,b,w=1,peer=false){
        const [s,t] = a < b ? [a,b] : [b,a];
        const k = peer ? `${s}||${t}||peer` : `${s}||${t}||me`;
        edgeMap.set(k, (edgeMap.get(k)||0)+w);
      }
    }

    // --- Render with D3 ---
    function render(nodes, links, meKey) {
      // compute degrees for scaling
      const deg = new Map(nodes.map(n => [n.id, 0]));
      links.forEach(l => { deg.set(l.source, deg.get(l.source)+1); deg.set(l.target, deg.get(l.target)+1); });
      nodes.forEach(n => n.degree = deg.get(n.id));

      const width = els.graph.clientWidth || 900;
      const height = els.graph.clientHeight || 600;

      d3.
